  $ ../../../../../../install/default/bin/stanc --auto-format cjs_add.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  int<lower=1> g;
  // Number of groups
  int<lower=1, upper=g> group[nind];
  // Groups
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  real beta1 = 0;
  // Corner constraint
  //  real beta1;
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
  //  beta1 = 0;      // Corner constraint
}
parameters {
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
  vector[n_occ_minus_1] gamma;
  // Time effects
  vector<lower=0, upper=1>[g] p_g;
  // Group-spec. recapture
  real beta2;
  // Prior for difference in male and
  // female survival
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  vector[g] beta;
  beta[1] = beta1;
  beta[2] = beta2;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = inv_logit(beta[group[i]] + gamma[t]);
      p[i, t] = p_g[group[i]];
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  //  p_g ~ uniform(0, 1);
  beta2 ~ normal(0, 10) T[-10, 10];
  gamma ~ normal(0, 10);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}
generated quantities {
  vector<lower=0, upper=1>[n_occ_minus_1] phi_g1;
  vector<lower=0, upper=1>[n_occ_minus_1] phi_g2;
  // inv_logit was vectorized in Stan 2.13
  phi_g1 = inv_logit(gamma);
  // Back-transformed survival of males
  phi_g2 = inv_logit(gamma + beta[2]);
  // Back-transformed survival of females
  /*
  for (t in 1:n_occ_minus_1) {
    phi_g1[t] = inv_logit(gamma[t]);
    phi_g2[t] = inv_logit(gamma[t] + beta[2]);
  }
  */
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_age.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  int<lower=1> max_age;
  // Maximum age
  int<lower=0, upper=max_age> x[nind, n_occasions - 1];
  // Age
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  real<lower=0, upper=1> mean_p;
  // Mean recapture
  vector<lower=0, upper=1>[max_age] beta;
  // Mean survival
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  // Survival
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  // Recapture
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = beta[x[i, t]];
      p[i, t] = mean_p;
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  beta ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_c_c.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = mean_phi;
      p[i, t] = mean_p;
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_cov_raneff.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  vector[n_occasions - 1] x;
  // Covariate
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  vector<lower=0, upper=nind>[n_occasions] n_captured;
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
  n_captured = rep_vector(0, n_occasions);
  for (t in 1 : n_occasions) 
    for (i in 1 : nind) 
      if (y[i, t]) 
        n_captured[t] = n_captured[t] + 1;
}
parameters {
  real beta;
  // Slope parameter
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
  vector[n_occ_minus_1] epsilon;
  real<lower=0, upper=10> sigma;
  // In case a weakly informative prior is used
  //  real<lower=0> sigma;
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Compoud declaration was enabled in Stan 2.13
  real mu = logit(mean_phi);
  //  real mu;
  //  mu = logit(mean_phi);
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = inv_logit(mu + beta * x[t] + epsilon[t]);
      p[i, t] = mean_p;
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  //  sigma ~ uniform(0, 10);
  // In case a weakly informative prior is used
  //  sigma ~ normal(5, 2.5);
  beta ~ normal(0, 100);
  epsilon ~ normal(0, sigma);
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}
generated quantities {
  real<lower=0> sigma2;
  vector<lower=0, upper=1>[n_occ_minus_1] phi_est;
  sigma2 = square(sigma);
  // inv_logit was vectorized in Stan 2.13
  phi_est = inv_logit(mu + beta * x + epsilon);
  // Yearly survival
  /*
  for (t in 1:n_occ_minus_1)
    phi_est[t] = inv_logit(mu + beta * x[t] + epsilon[t]); 
  */
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_group.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  int<lower=1> g;
  // Number of groups
  int<lower=1, upper=g> group[nind];
  // Groups
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  vector<lower=0, upper=1>[g] phi_g;
  // Group-specific survival
  vector<lower=0, upper=1>[g] p_g;
  // Group-specific recapture
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = phi_g[group[i]];
      p[i, t] = p_g[group[i]];
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //   phi_g ~ uniform(0, 1);
  //   p_g ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_group_raneff.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  int<lower=1> g;
  // Number of groups
  int<lower=1, upper=g> group[nind];
  // Groups
}
transformed data {
  // Compoud declaration is enabled in Stan 2.13
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  vector[g] beta;
  real mean_beta;
  // Logit of mean survival
  real<lower=0, upper=10> sigma;
  // SD of logit of survival variability
  // In case a weakly informative prior is used
  //  real<lower=0> sigma;
  real<lower=0, upper=1> mean_p;
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = inv_logit(beta[group[i]]);
      p[i, t] = mean_p;
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  phi_g ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  //  sigma ~ uniform(0, 10);
  // In case a weakly informative prior is used
  //  sigma ~ normal(5, 2.5);
  beta ~ normal(mean_beta, sigma);
  mean_beta ~ normal(0, sqrt(1000));
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}
generated quantities {
  real<lower=0, upper=1> mean_phi;
  vector<lower=0, upper=1>[g] phi_g;
  // Group-specific survival
  mean_phi = inv_logit(mean_beta);
  phi_g = inv_logit(beta);
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_ind_raneff.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
  vector[nind] epsilon;
  real<lower=0, upper=5> sigma;
  // In case a weakly informative prior is used
  //  real<lower=0> sigma;
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  real mu;
  // Constraints
  mu = logit(mean_phi);
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = inv_logit(mu + epsilon[i]);
      p[i, t] = mean_p;
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  //  sigma ~ uniform(0, 5);
  // In case a weaily informative prior is used
  //  sigma ~ normal(2.5, 1.25);
  epsilon ~ normal(0, sigma);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}
generated quantities {
  real<lower=0> sigma2;
  sigma2 = square(sigma);
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_mnl.stan
data {
  int<lower=0> n_occasions;
  // Number of capture occasions
  int<lower=0> marr[n_occasions - 1, n_occasions];
  // m-array
}
transformed data {
  // Compoud declaration was enabled in Stan 2.13
  int n_occasions_minus_1 = n_occasions - 1;
  //  int n_occasions_minus_1;
  int r[n_occasions - 1];
  //  n_occasions_minus_1 = n_occasions - 1;
  // Calculate the number of birds released each year
  for (t in 1 : n_occasions_minus_1) 
    r[t] = sum(marr[t]);
}
parameters {
  vector<lower=0, upper=1>[n_occasions_minus_1] phi;
  // Survival
  vector<lower=0, upper=1>[n_occasions_minus_1] p;
  // Recapture
}
transformed parameters {
  vector<lower=0, upper=1>[n_occasions_minus_1] q;
  simplex[n_occasions] pr[n_occasions_minus_1];
  q = 1.0 - p;
  // Probability of non-recapture
  // Define the cell probabilities of the m-array
  for (t in 1 : n_occasions_minus_1) {
    // Main diagonal
    pr[t, t] = phi[t] * p[t];
    // Above main diagonal
    for (j in (t + 1) : n_occasions_minus_1) 
      pr[t, j] = prod(phi[t : j]) * prod(q[t : (j - 1)]) * p[j];
    // Below main diagonal
    pr[t,  : (t - 1)] = rep_vector(0, t - 1);
  }
  // Last column: probability of non-recapture
  for (t in 1 : n_occasions_minus_1) 
    pr[t, n_occasions] = 1 - sum(pr[t,  : n_occasions_minus_1]);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  phi ~ uniform(0, 1);
  //  p ~ uniform(0, 1);
  // Define the multinomial likelihood
  for (t in 1 : n_occasions_minus_1) 
    marr[t] ~ multinomial(pr[t]);
}
generated quantities {
  real fit;
  real fit_new;
  matrix[n_occasions_minus_1, n_occasions] E_org;
  matrix[n_occasions_minus_1, n_occasions] E_new;
  vector[n_occasions] expmarr[n_occasions_minus_1];
  int<lower=0> marr_new[n_occasions_minus_1, n_occasions];
  // Assess model fit using Freeman-Tukey statistic
  // Compute fit statistics for observed data
  for (t in 1 : n_occasions_minus_1) {
    expmarr[t] = r[t] * pr[t];
    for (j in 1 : n_occasions) {
      E_org[t, j] = square((sqrt(marr[t][j]) - sqrt(expmarr[t][j])));
    }
    //j
  }
  //t
  // Generate replicate data and compute fit stats from them
  for (t in 1 : n_occasions_minus_1) {
    marr_new[t] = multinomial_rng(pr[t], r[t]);
    for (j in 1 : n_occasions) {
      E_new[t, j] = square((sqrt(marr_new[t][j]) - sqrt(expmarr[t][j])));
    }
  }
  fit = sum(E_org);
  fit_new = sum(E_new);
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_mnl_age.stan
data {
  int<lower=0> n_occasions;
  // Number of capture occasions
  int<lower=0> marr_j[n_occasions - 1, n_occasions];
  // Juv. m-array
  int<lower=0> marr_a[n_occasions - 1, n_occasions];
  // Ad. m-array
}
transformed data {
  // Compoud declaration is enabled in Stan 2.13
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  //  n_occ_minus_1 = n_occasions - 1;
}
parameters {
  real<lower=0, upper=1> mean_phijuv;
  // Mean juv. survival
  real<lower=0, upper=1> mean_phiad;
  // Mean ad. survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
}
transformed parameters {
  vector<lower=0, upper=1>[n_occ_minus_1] phi_juv;
  vector<lower=0, upper=1>[n_occ_minus_1] phi_ad;
  vector<lower=0, upper=1>[n_occ_minus_1] p;
  vector<lower=0, upper=1>[n_occ_minus_1] q;
  simplex[n_occasions] pr_j[n_occ_minus_1];
  simplex[n_occasions] pr_a[n_occ_minus_1];
  // Constraints
  phi_juv = rep_vector(mean_phijuv, n_occ_minus_1);
  phi_ad = rep_vector(mean_phiad, n_occ_minus_1);
  p = rep_vector(mean_p, n_occ_minus_1);
  q = 1.0 - p;
  // Probability of non-recapture
  // Define the cell probabilities of the m-arrays
  // Main diagonal
  for (t in 1 : n_occ_minus_1) {
    pr_j[t, t] = phi_juv[t] * p[t];
    pr_a[t, t] = phi_ad[t] * p[t];
    // Above main diagonal
    for (j in (t + 1) : n_occ_minus_1) {
      pr_j[t, j] = phi_juv[t] * prod(phi_ad[(t + 1) : j])
                   * prod(q[t : (j - 1)]) * p[j];
      pr_a[t, j] = prod(phi_ad[t : j]) * prod(q[t : (j - 1)]) * p[j];
    }
    // Below main diagonal
    pr_j[t,  : (t - 1)] = rep_vector(0, t - 1);
    pr_a[t,  : (t - 1)] = rep_vector(0, t - 1);
  }
  // Last column: probability of non-recapture
  for (t in 1 : n_occ_minus_1) {
    pr_j[t, n_occasions] = 1 - sum(pr_j[t,  : n_occ_minus_1]);
    pr_a[t, n_occasions] = 1 - sum(pr_a[t,  : n_occ_minus_1]);
  }
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phijuv ~ uniform(0, 1);
  //  mean_phiad ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  // Define the multinomial likelihood
  for (t in 1 : n_occ_minus_1) {
    marr_j[t] ~ multinomial(pr_j[t]);
    marr_a[t] ~ multinomial(pr_a[t]);
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_mnl_ran.stan
data {
  int<lower=0> n_occasions;
  // Number of capture occasions
  int<lower=0> marr[n_occasions - 1, n_occasions];
  // m-array
}
transformed data {
  // Compoud declaration is enabled in Stan 2.13
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int r[n_occasions];
  //  n_occ_minus_1 = n_occasions - 1;
  for (t in 1 : n_occ_minus_1) 
    r[t] = sum(marr[t]);
}
parameters {
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
  real<lower=0> sigma;
  vector[n_occ_minus_1] epsilon;
}
transformed parameters {
  real mu;
  vector<lower=0, upper=1>[n_occ_minus_1] phi;
  vector<lower=0, upper=1>[n_occ_minus_1] p;
  vector<lower=0, upper=1>[n_occ_minus_1] q;
  simplex[n_occasions] pr[n_occ_minus_1];
  mu = logit(mean_phi);
  // Constraints
  // inv_logit was vectorized in Stan 2.13
  phi = inv_logit(mu + epsilon);
  //  for (t in 1:n_occ_minus_1)
  //    phi[t] = inv_logit(mu + epsilon[t]);
  p = rep_vector(mean_p, n_occ_minus_1);
  q = 1.0 - p;
  // Probability of non-recapture
  // Define the cell probabilities of the m-arrays
  // Main diagonal
  for (t in 1 : n_occ_minus_1) {
    pr[t, t] = phi[t] * p[t];
    // Above main diagonal
    for (j in (t + 1) : n_occ_minus_1) 
      pr[t, j] = prod(phi[t : j]) * prod(q[t : (j - 1)]) * p[j];
    // Below main diagonal
    pr[t,  : (t - 1)] = rep_vector(0, t - 1);
  }
  // Last column: probability of non-recapture
  for (t in 1 : n_occ_minus_1) 
    pr[t, n_occasions] = 1 - sum(pr[t,  : n_occ_minus_1]);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  //  sigma ~ uniform(0, 5);
  // In case a weakly informative prior is used
  //  sigma ~ normal(2.5, 1.25);
  epsilon ~ normal(0, sigma);
  // Define the multinomial likelihood
  for (t in 1 : (n_occ_minus_1)) 
    marr[t] ~ multinomial(pr[t]);
}
generated quantities {
  real<lower=0> sigma2;
  real<lower=0> sigma2_real;
  vector[n_occasions] expmarr[n_occ_minus_1];
  int marr_new[n_occ_minus_1, n_occasions];
  matrix[n_occ_minus_1, n_occasions] E_org;
  matrix[n_occ_minus_1, n_occasions] E_new;
  real fit;
  real fit_new;
  sigma2 = square(sigma);
  // Temporal variance on real scale
  sigma2_real = sigma2 * square(mean_phi * (1 - mean_phi));
  // Assess model fit using Freeman-Tukey statistic
  // Compute fit statistics for observed data
  for (t in 1 : n_occ_minus_1) {
    expmarr[t] = r[t] * pr[t];
    for (j in 1 : n_occasions) 
      E_org[t, j] = square((sqrt(marr[t, j]) - sqrt(expmarr[t][j])));
  }
  // Generate replicate data and compute fit stats from them
  for (t in 1 : n_occ_minus_1) {
    marr_new[t] = multinomial_rng(pr[t], r[t]);
    for (j in 1 : n_occasions) 
      E_new[t, j] = square((sqrt(marr_new[t, j]) - sqrt(expmarr[t][j])));
  }
  fit = sum(E_org);
  fit_new = sum(E_new);
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_t_t.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  vector<lower=0, upper=1>[n_occ_minus_1] phi_t;
  // Mean survival
  vector<lower=0, upper=1>[n_occ_minus_1] p_t;
  // Mean recapture
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = phi_t[t];
      p[i, t] = p_t[t];
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  phi_t ~ uniform(0, 1);
  //  p_t ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_temp_corr.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  int<lower=1> g;
  // Number of groups
  int<lower=1, upper=g> group[nind];
  // Groups
  real df;
  // Degree of freedom
  matrix[g, g] R;
  // Scale matrix
}
transformed data {
  // Compoud declaration is enabled in Stan 2.13
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  vector<lower=0, upper=1>[g] mean_phi;
  // Mean group-spec. survival
  real<lower=0, upper=1> p_g[g];
  // Group-spec. recapture
  matrix[n_occ_minus_1, g] eta_phi;
  cov_matrix[g] Sigma;
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  vector[g] mu_phi;
  for (u in 1 : g) 
    mu_phi[u] = logit(mean_phi[u]);
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = inv_logit(eta_phi[t, group[i]]);
      p[i, t] = p_g[group[i]];
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // for survival parameters
  Sigma ~ inv_wishart(df, R);
  for (t in 1 : n_occ_minus_1) 
    eta_phi[t] ~ multi_normal(mu_phi, Sigma);
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  // for recapture parameters
  //  p_g ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_temp_fixeff.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
}
transformed data {
  int n_occ_minus_1;
  // Compoud declaration is enabled in Stan 2.13
  //  int n_occ_minus_1 = n_occasions - 1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  vector<lower=0, upper=1>[n_occ_minus_1] alpha;
  // Mean survival
  vector<lower=0, upper=1>[n_occ_minus_1] beta;
  // Mean recapture
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = alpha[t];
      p[i, t] = beta[t];
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  alpha ~ uniform(0, 1);
  //  beta ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_temp_raneff.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
}
transformed data {
  // Compoud declaration is enabled in Stan 2.13
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> mean_p;
  // Mean recapture
  real<lower=0, upper=10> sigma;
  // In case a weakly informative prior is used
  //  real<lower=0> sigma;
  vector[n_occ_minus_1] epsilon;
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  real mu;
  mu = logit(mean_phi);
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = inv_logit(mu + epsilon[t]);
      p[i, t] = mean_p;
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  mean_p ~ uniform(0, 1);
  //  sigma ~ uniform(0, 10);
  // In case weakly informative prior is used
  //  sigma ~ normal(5, 2.5);
  epsilon ~ normal(0, sigma);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}
generated quantities {
  real<lower=0> sigma2;
  sigma2 = square(sigma);
}

  $ ../../../../../../install/default/bin/stanc --auto-format cjs_trap.stan
// This models is derived from section 12.3 of "Stan Modeling Language
// User's Guide and Reference Manual"
functions {
  int first_capture(int[] y_i) {
    for (k in 1 : size(y_i)) 
      if (y_i[k]) 
        return k;
    return 0;
  }
  int last_capture(int[] y_i) {
    for (k_rev in 0 : (size(y_i) - 1)) {
      // Compoud declaration was enabled in Stan 2.13
      int k = size(y_i) - k_rev;
      //      int k;
      //      k = size(y_i) - k_rev;
      if (y_i[k]) 
        return k;
    }
    return 0;
  }
  matrix prob_uncaptured(int nind, int n_occasions, matrix p, matrix phi) {
    matrix[nind, n_occasions] chi;
    for (i in 1 : nind) {
      chi[i, n_occasions] = 1.0;
      for (t in 1 : (n_occasions - 1)) {
        // Compoud declaration was enabled in Stan 2.13
        int t_curr = n_occasions - t;
        int t_next = t_curr + 1;
        /*
        int t_curr;
        int t_next;
        
        t_curr = n_occasions - t;
        t_next = t_curr + 1;
        */
        chi[i, t_curr] = (1 - phi[i, t_curr])
                         + phi[i, t_curr] * (1 - p[i, t_next - 1])
                           * chi[i, t_next];
      }
    }
    return chi;
  }
}
data {
  int<lower=0> nind;
  // Number of individuals
  int<lower=2> n_occasions;
  // Number of capture occasions
  int<lower=0, upper=1> y[nind, n_occasions];
  // Capture-history
  int m[nind, n_occasions - 1];
}
transformed data {
  int n_occ_minus_1 = n_occasions - 1;
  //  int n_occ_minus_1;
  int<lower=0, upper=n_occasions> first[nind];
  int<lower=0, upper=n_occasions> last[nind];
  //  n_occ_minus_1 = n_occasions - 1;
  for (i in 1 : nind) 
    first[i] = first_capture(y[i]);
  for (i in 1 : nind) 
    last[i] = last_capture(y[i]);
}
parameters {
  real<lower=0, upper=1> mean_phi;
  // Mean survival
  real<lower=0, upper=1> beta[2];
  // Mean recapture
}
transformed parameters {
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] phi;
  matrix<lower=0, upper=1>[nind, n_occ_minus_1] p;
  matrix<lower=0, upper=1>[nind, n_occasions] chi;
  // Constraints
  for (i in 1 : nind) {
    for (t in 1 : (first[i] - 1)) {
      phi[i, t] = 0;
      p[i, t] = 0;
    }
    for (t in first[i] : n_occ_minus_1) {
      phi[i, t] = mean_phi;
      p[i, t] = beta[m[i, t]];
    }
  }
  chi = prob_uncaptured(nind, n_occasions, p, phi);
}
model {
  // Priors
  // Uniform priors are implicitly defined.
  //  mean_phi ~ uniform(0, 1);
  //  beta ~ uniform(0, 1);
  // Likelihood
  for (i in 1 : nind) {
    if (first[i] > 0) {
      for (t in (first[i] + 1) : last[i]) {
        1 ~ bernoulli(phi[i, t - 1]);
        y[i, t] ~ bernoulli(p[i, t - 1]);
      }
      1 ~ bernoulli(chi[i, last[i]]);
    }
  }
}

