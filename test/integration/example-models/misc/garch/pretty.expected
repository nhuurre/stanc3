  $ ../../../../../../install/default/bin/stanc --auto-format arch1.stan
// ARCH(1) model
data {
  int<lower=0> T;
  // measurement time indexes
  real r[T];
  // return at time t
}
parameters {
  real mu;
  // average return
  real<lower=0> alpha0;
  // noise intercept coefficient
  real<lower=0, upper=1> alpha1;
  // noise slope coefficient
}
model {
  for (t in 2 : T) 
    r[t] ~ normal(mu, sqrt(alpha0 + alpha1 * pow(r[t - 1] - mu, 2)));
}

  $ ../../../../../../install/default/bin/stanc --auto-format garch1_1.stan
// GARCH(1,1)
data {
  int<lower=2> T;
  real r[T];
  real<lower=0> sigma1;
  int<lower=0> T_out;
}
parameters {
  real mu;
  real<lower=0> alpha0;
  real<lower=0, upper=1> alpha1;
  real<lower=0, upper=(1 - alpha1)> beta1;
}
transformed parameters {
  real<lower=0> sigma[T];
  sigma[1] = sigma1;
  for (t in 2 : T) 
    sigma[t] = sqrt(alpha0 + +alpha1 * square(r[t - 1] - mu)
                    + beta1 * square(sigma[t - 1]));
}
model {
  r ~ normal(mu, sigma);
}
generated quantities {
  real r_out[T_out];
  real sigma_out[T_out];
  sigma_out[1] = sqrt(alpha0 + alpha1 * square(r[T] - mu)
                      + beta1 * square(sigma[T]));
  r_out[1] = normal_rng(mu, sigma_out[1]);
  for (t in 2 : T_out) {
    sigma_out[t] = sqrt(alpha0 + alpha1 * square(r_out[t - 1] - mu)
                        + beta1 * square(sigma_out[t - 1]));
    r_out[t] = normal_rng(mu, sigma_out[t]);
  }
}

  $ ../../../../../../install/default/bin/stanc --auto-format koyck.stan
// geometric lag time-series (Koyck 1951)
//
// http://en.wikipedia.org/wiki/Distributed_lag
data {
  int<lower=0> T;
  // number of time points
  real y[T];
  // output at time t
  real x[T];
  // predictor for time t
}
parameters {
  real alpha;
  // intercept
  real beta;
  // slope
  real<lower=0, upper=1> lambda;
  // lag
  real<lower=0> sigma;
  // noise scale
}
model {
  alpha ~ cauchy(0, 5);
  beta ~ cauchy(0, 5);
  lambda ~ uniform(0, 1);
  sigma ~ cauchy(0, 5);
  for (t in 2 : T) 
    y[t] ~ normal(alpha + beta * x[t] + lambda * y[t - 1], sigma);
}

